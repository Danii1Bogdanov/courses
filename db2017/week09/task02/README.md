Теперь нам предстоит поупражняться в поиске в JSON и составлении JSON объектов.

В таблице `Planet` есть столбец `wiki_jsonb` с типом JSONB, в котором хранятся JSON объекты со следующей структурой:
в поле "features" может быть вложенный объект с полями, повторяющими по смыслу, структуре и соглашениям поля столбца `Planet.wiki` из предыдущего задания
в поле `"log"` может быть записан журнал посещений -- массив, содержащий в себе объекты с именами капитанов, посетивших планету и их короткими сообщениями. Имя записано в поле `"commander"`, а сообщение в поле `"message"`

Пример строки таблицы `Planet`, где в `wiki_jsonb` есть все указанные выше поля:

```sql
id  name      wiki_jsonb
-------------------
1   Интеропия {"features": {"food": "1", "danger": "0", "dinosaurs": "1", "gravitsapa": "1"}, 
               "log": [
                  {"commander": "Ийон Тихий", "message": "Видел огромного курдля"}, 
                  {"commander": "Громозека", "message": "Да нет тут никаких огромных динозавров, только крошечные!"}
                ]
              }
```

Все эти поля, разумеется, могут и отсутствовать в какой-то другой планете.

Кроме этого, у вас есть таблица

```sql
CommanderAchievements(
    commander_id INT PRIMARY KEY REFERENCES Commander, 
    data JSONB)
```

где в столбце `data` у каждого капитана записан объект, состоящий из полей `"rating"` и `"selfies"`. В поле `"rating"` записан рейтинг капитана, а поле `"selfies"` -- это массив, в котором будут записываться селфи, сделанные капитаном на разных планетах. После инициализации этот объект у каждого капитана выглядит  примерно так:

```sql
data
------
{"rating": "Elite", "selfies": []}
```

где конкретное значение в поле rating соответствует действительному рейтингу капитана.

Вам нужно найти планеты, где по нашим данным есть динозавры (это свойство у нас называется `"dinosaurs"`) и для каждой записи, оставленной капитаном в журнале посещений, сделать новую запись в массиве `"selfies"` у соответствующего капитана в таблице `CommanderAchievements`, состоящую из полей: `{"with": "dino", "planet": <название планеты>}`.

Для указанного выше примера строки из таблицы Planet в таблице CommanderAchievements у соответствующих капитанов должны были бы появиться записи вида:

```
{"rating": "Elite", "selfies": [{"planet": "Интеропия", "with": "dino"}]}
```

Вам нужно только написать запрос, выдающий новые значения тех строк таблицы CommanderAchievements, которые должны быть обновлены согласно данным в журналах. Собственно обновление таблицы делать не нужно. В результате запроса должны быть столбцы commander_id INT, data JSONB. Выборка из таблицы CommanderAchievements сама по себе будет валидным (но неправильным) ответом:

```sql
SELECT commander_id, data FROM CommanderAchievements
```

Обратите внимание, что капитан может оставить записи в нескольких журналах посещений и даже несколько раз в одном и том же журнале. Каждая такая запись должна превращаться в соответствующий объект в массиве "selfie".

Вам могут пригодиться [функции PostgreSQL](https://postgrespro.ru/docs/postgresql/10/functions-json), выполняющие преобразования JSON-массивов в таблицы и наоборот, преобразующие значения столбца выборки в JSON-массив. Обратите внимание, что функции, как правило, дублируются для типов JSON и JSONB и визуально они отличаются лишь словами json/jsonb в названии функции. Мы работаем с JSONB и нам всегда нужны функции, содержащие в названии "jsonb".

Расширение `JsQuery` в проверяющем роботе недоступно в принципе
